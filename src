# Directory: /src/models/
# Implementation of classes from the UML class diagram

import uuid
from datetime import datetime, timedelta
import json
import random

# Base User class
class User:
    def __init__(self, name, email, password_hash):
        self._id = uuid.uuid4()
        self.name = name
        self.email = email
        self.password_hash = password_hash
        self.role = "user"
        self.last_login = None

    @property
    def id(self):
        return self._id

    def login(self):
        self.last_login = datetime.now()
        return True

    def logout(self):
        return True

    def update_profile(self, name=None, email=None):
        if name:
            self.name = name
        if email:
            self.email = email

# Learner subclass
class Learner(User):
    def __init__(self, name, email, password_hash, grade_level):
        super().__init__(name, email, password_hash)
        self.grade_level = grade_level
        self.role = "learner"
        self.submissions = []

    def submit_assessment(self, assessment, content):
        submission = Submission(self.id, assessment.id, content)
        self.submissions.append(submission)
        return submission

    def edit_submission(self, submission_id, new_content):
        for submission in self.submissions:
            if submission.id == submission_id:
                submission.content = new_content
                submission.timestamp = datetime.now()
                return True
        return False

    def view_marks(self):
        return {s.id: s.marks for s in self.submissions}

    def chat_with_educator(self):
        return "Chat started"

# Educator subclass
class Educator(User):
    def __init__(self, name, email, password_hash):
        super().__init__(name, email, password_hash)
        self.role = "educator"
        self.assessments = []

    def upload_assessment(self, title, instructions, deadline):
        assessment = Assessment(title, instructions, deadline, self.id)
        self.assessments.append(assessment)
        return assessment

    def mark_submission(self, submission, marks):
        submission.marks = marks
        submission.status = "marked"

    def generate_report(self, criteria="performance"):
        report = Report(self.id, criteria)
        report.generate()
        return report

    def send_notification(self, recipient_id, message):
        notification = Notification(recipient_id, message)
        notification.send()
        return notification

# Assessment class
class Assessment:
    def __init__(self, title, instructions, deadline, educator_id):
        self.id = uuid.uuid4()
        self.title = title
        self.instructions = instructions
        self.deadline = deadline
        self.educator_id = educator_id
        self.created_at = datetime.now()

    def is_deadline_passed(self):
        return datetime.now() > self.deadline

    def notify_learners(self):
        return "Notification sent to learners"

# Submission class
class Submission:
    def __init__(self, learner_id, assessment_id, content):
        self.id = uuid.uuid4()
        self.learner_id = learner_id
        self.assessment_id = assessment_id
        self.content = content
        self.timestamp = datetime.now()
        self.status = "submitted"
        self.marks = 0
        self.otp = OTP(self.learner_id)

    def verify_otp(self, code):
        return self.otp.validate(code)

    def update_status(self, new_status):
        self.status = new_status

# Report class
class Report:
    def __init__(self, educator_id, criteria):
        self.id = uuid.uuid4()
        self.educator_id = educator_id
        self.criteria = criteria
        self.generated_at = datetime.now()
        self.report_data = {}

    def generate(self):
        # Simulate report generation
        self.report_data = {"summary": f"Report based on {self.criteria}"}

    def download(self):
        return json.dumps(self.report_data, indent=2)

# OTP class
class OTP:
    def __init__(self, user_id):
        self.code = str(random.randint(100000, 999999))
        self.user_id = user_id
        self.expires_at = datetime.now() + timedelta(minutes=5)
        self.verified = False

    def generate(self):
        self.code = str(random.randint(100000, 999999))
        self.expires_at = datetime.now() + timedelta(minutes=5)

    def validate(self, code):
        if self.code == code and datetime.now() <= self.expires_at:
            self.verified = True
            return True
        return False

# Notification class
class Notification:
    def __init__(self, recipient_id, message):
        self.id = uuid.uuid4()
        self.recipient_id = recipient_id
        self.message = message
        self.timestamp = datetime.now()
        self.read = False

    def send(self):
        print(f"Sending to {self.recipient_id}: {self.message}")

    def mark_as_read(self):
        self.read = True
